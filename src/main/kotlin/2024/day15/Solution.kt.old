package `2024`.day15

import utilities.readInput

fun main() {
    val input = readInput("2024/day15/input.txt")
    println("Part 1: ${part1(input)}")
    println("Part 2: ${part2(input)}")
}

sealed class Obstacle(val char: Char) {
    object Wall : Obstacle('#')
    object Robot : Obstacle('@')
    object Box : Obstacle('O')
    object Empty : Obstacle('.')
    object BoxLeft : Obstacle('[')
    object BoxRight : Obstacle(']')
    object RobotSpace : Obstacle('.')

    companion object {
        fun fromChar(char: Char): Obstacle {
            return when (char) {
                '#' -> Wall
                '@' -> Robot
                'O' -> Box
                '.' -> Empty
                '[' -> BoxLeft
                ']' -> BoxRight
                else -> throw IllegalArgumentException("Invalid character: $char")
            }
        }
    }
}

data class Point(val row: Int, val col: Int) {
    fun nextPosition(direction: Char): Point {
        return when (direction) {
            '^' -> copy(row = row - 1)
            'v' -> copy(row = row + 1)
            '<' -> copy(col = col - 1)
            '>' -> copy(col = col + 1)
            else -> throw IllegalArgumentException("Invalid direction: $direction")
        }
    }
}

data class Warehouse(
    val grid: List<MutableList<Obstacle>>,
    var robotPosition: Point,
    val isWide: Boolean = false
) {
    private fun isBox(obstacle: Obstacle) = when {
        isWide -> obstacle == Obstacle.BoxLeft // start of wide box, next cell will be set to box right after checking prev (this one)
        else -> obstacle == Obstacle.Box
    }

    private fun findBoxStack(start: Point, direction: Char): List<Point> {
        val boxPositions = mutableListOf<Point>()
        var currentPos = start

        while (isBox(grid[currentPos.row][currentPos.col])) {
            // check both parts
            if (isWide && grid[currentPos.row][currentPos.col + 1] != Obstacle.BoxRight) break

            boxPositions.add(currentPos)
            currentPos = currentPos.nextPosition(direction)
        }

        // Check if stack is pushable
        return if (isWide) {
            if (grid[currentPos.row][currentPos.col] == Obstacle.Empty &&
                grid[currentPos.row][currentPos.col + 1] == Obstacle.Empty
            ) boxPositions else emptyList() // blocked by wall
        } else {
            if (grid[currentPos.row][currentPos.col] == Obstacle.Empty) boxPositions else emptyList() // blocked by wall
        }
    }

    fun move(direction: Char) {
        val nextRobotPos = robotPosition.nextPosition(direction)

        when (grid[nextRobotPos.row][nextRobotPos.col]) {
            Obstacle.Wall -> return // blocked, do nothing
            Obstacle.Empty, Obstacle.RobotSpace -> {
                if (!isWide || direction != '>' || grid[nextRobotPos.row][nextRobotPos.col + 1] == Obstacle.Empty) {
                    moveRobot(nextRobotPos)
                }
            }

            Obstacle.BoxLeft -> {
                val boxStack = findBoxStack(nextRobotPos, direction)
                if (boxStack.isEmpty()) return

                // Move all boxes
                boxStack.reversed().forEach { boxPos ->
                    val nextPos = boxPos.nextPosition(direction)
                    if (isWide) {
                        grid[nextPos.row][nextPos.col] = Obstacle.BoxLeft
                        grid[nextPos.row][nextPos.col + 1] = Obstacle.BoxRight
                        grid[boxPos.row][boxPos.col] = if (boxPos == nextRobotPos) Obstacle.Robot else Obstacle.Empty
                        grid[boxPos.row][boxPos.col + 1] =
                            if (boxPos == nextRobotPos) Obstacle.RobotSpace else Obstacle.Empty
                    } else {
                        grid[nextPos.row][nextPos.col] = Obstacle.Box
                        grid[boxPos.row][boxPos.col] = if (boxPos == nextRobotPos) Obstacle.Robot else Obstacle.Empty
                    }
                }
                moveRobot(nextRobotPos)
            }

            else -> return
        }
    }

    private fun moveRobot(newPos: Point) {
        if (isWide) {
            grid[robotPosition.row][robotPosition.col] = Obstacle.Empty
            grid[robotPosition.row][robotPosition.col + 1] = Obstacle.Empty
            grid[newPos.row][newPos.col] = Obstacle.Robot
            grid[newPos.row][newPos.col + 1] = Obstacle.RobotSpace
        } else {
            grid[robotPosition.row][robotPosition.col] = Obstacle.Empty
            grid[newPos.row][newPos.col] = Obstacle.Robot
        }
        robotPosition = newPos
    }

    fun calculateGPSSum(): Int {
        var sum = 0
        for (row in grid.indices) {
            for (col in grid[row].indices) {
                if (isBox(grid[row][col])) {
                    sum += (row * 100) + col
                }
            }
        }
        return sum
    }

    override fun toString(): String {
        val builder = StringBuilder()
        grid.forEach { row ->
            builder.appendLine(row.joinToString("") { it.char.toString() })
        }
        builder.appendLine()
        return builder.toString()
    }
}

fun parseInput(input: List<String>, isWide: Boolean = false): Pair<Warehouse, String> {
    // warehouse grid
    val warehouseLines = input.takeWhile { it.isNotEmpty() }

    val movesBuilder = StringBuilder()
    // movement inputs
    input.subList(warehouseLines.size + 1, input.size).forEach { m ->
        movesBuilder.append(m.filter { it in "^v<>" })
    }

    var robotPos = Point(0, 0)
    val grid = warehouseLines.mapIndexed { row, line ->
        line.mapIndexed { col, char ->
            val obstacle = Obstacle.fromChar(char)
            if (obstacle == Obstacle.Robot) {
                robotPos = Point(row, col)
            }
            obstacle
        }.toMutableList()
    }

    return Warehouse(grid, robotPos, isWide) to movesBuilder.toString()
}

fun makeWideWarehouse(input: List<String>): List<String> =
    input.takeWhile { it.isNotEmpty() }.map { line ->
        line.map { char ->
            when (char) {
                '#' -> "##"
                'O' -> "[]"
                '.' -> ".."
                '@' -> "@."
                else -> throw IllegalArgumentException("Invalid character: $char")
            }
        }.joinToString("")
    }

fun part1(input: List<String>): Int {
    val (warehouse, moves) = parseInput(input)
    moves.forEach { direction -> warehouse.move(direction) }
    return warehouse.calculateGPSSum()
}

fun part2(input: List<String>): Int {
    val wideInput = makeWideWarehouse(input) + input.dropWhile { it.isNotEmpty() }
    val (warehouse, moves) = parseInput(wideInput, isWide = true)
    moves.forEach { warehouse.move(it) }
    return warehouse.calculateGPSSum()
}